package com.interview.leetcode.uber.medium;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

/*
https://leetcode.com/problems/random-pick-index/description/

Given an array of integers with possible duplicates, randomly output the index of a given target number.
You can assume that the given target number must exist in the array.

Note:
The array size can be very large. Solution that uses too much extra space will not pass the judge.

Example:

int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);

===================Solution Approach - Probability Theory - Think in Streams=====================================================
1) Consider each number as new entry like in streams.
Ex: 1,1,1
2) Initially we have only one1. How we will choose. No competition 100% "1AtIndex0" selected.
3) Now we see two1. How we will choose. Previous Winner or So for winner is "1AtIndex0".
Generate number {0,1}. If 0 change winner as "1AtIndex1".
					   If 1 keep previous winner "1AtIndex0".
4) Now we see Three1. How we will choose. Previous Winner or So for winner is {1AtIndex0 or 1AtIndex1}
Generate number {0,1,2}. If 0 change winner as 1 at index2.
					     Else keep the previous winner.
********Note Important********
1) So each time time, for each number, we announce them as winner, if 0 was generated by random.
2) So first time  "1AtIndex0" gets 100% probability. Because out of {0} only it can be selected.
3) So second time "1AtIndex1" gets 50% probability or 1/2 probability. Because out of {0,1}. Picking 0 is 1/2 probability.
4) So third time  "1AtIndex2" gets 33% probability or 1/3 probability. Because out of {0,1,2}. Picking 0 is 1/3 probability.
================================================================================================================================


Note: "Random" number generated for 1 -> {0}
								for 2 -> {0,1}.
								for 3 -> {0,1,2}
===================================
Similar to the problem "LinkedListRandomNode"
This is also called "Reservoir Sampling solution"
 */
public class RandomPickIndex {
  Map<Integer, List<Integer>> map = new HashMap<>();
  Random random = new Random();

  public RandomPickIndex(int[] nums) {
    for (int i = 0; i < nums.length; ++i)
      map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);
  }

  public int pick(int target) {
    int targetWinnerIndex = 0, count = 1;
    for (int index : map.get(target)) {
      int currentRandom = random.nextInt(count);
      if (currentRandom == 0) targetWinnerIndex = index;
      count++;
    }
    return targetWinnerIndex;
  }
}
