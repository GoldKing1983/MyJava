package com.sample.datastructure.algorithm.interview;

/*
The basic idea of dynamic programming is to store the results of previous calculation and
reuse it in future calculations, instead of recalculating them.

 Apply dp only when question is about count/trueOrFalse/max/min.... 
 If anywhere combination/permutation/subList/sequence is asked never try DP.... 
 Sometimes it is not possible, sometimes it complicates... I can point 100+ problems... 
 Ex:wordBreak1 u have all combinationOfSolution(Recursion/MemoDP/BottomUpDP/BFS). But wordBreak2 most people solution is BFS/DFS only...
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns
=======For the coin-change problem======
1) Define SubProblems (1 coin to make target)
2) Relate SubProblem solutions (2 coin to make target)

3) Recurse & memoize or build DP table bottom-up
4) Solve original problem

===============================Problems===============================
1) UniquePathsDP
2) MinimumPathSumDP
3) MaximalSquare
4) CountingBits
===============================Fibonacci style DP======================
1) ClimbingStairs
2) MinCostClimbingStairs
3) BestTimeToBuyAndSellStockWithCooldown
4) HouseRobber
5) PaintFence
6) PaintHouse
 */
public class DPInterviewPoint {
}
